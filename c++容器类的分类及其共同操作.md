# c++容器类的分类及其共同操作

## 前言

C++ 标准库中的容器类（Containers）主要用于存储和管理对象集合，根据其特性和用途可分为以下几大类：

### 1. 序列容器（Sequence Containers）

**特点**：元素按照插入顺序存储，位置由插入顺序决定（而非元素值），支持通过索引或迭代器访问元素。

包含的容器：

- vector：动态数组，元素连续存储，尾部插入 / 删除效率高（O (1)），中间插入 / 删除效率低（O (n)），支持随机访问。

- deque：双端队列，元素分段连续存储，两端插入 / 删除效率高（O (1)），支持随机访问。

- list：双向链表，元素不连续存储，任意位置插入 / 删除效率高（O (1)），但不支持随机访问（只能双向遍历）。

- forward_list：单向链表（C++11 新增），比list更节省空间，仅支持单向遍历，任意位置插入 / 删除效率高（O (1)）。

- array：固定大小数组（C++11 新增），封装了原生数组，大小编译期确定，支持随机访问，比原生数组更安全。

### 2. 关联容器（Associative Containers）

**特点**：元素按 “键（key）” 排序存储（默认升序），底层通常基于红黑树实现，查找、插入、删除操作效率为 O (log n)，不支持随机访问。

包含的容器：

- set：存储唯一键（key 即元素），元素不可重复，自动排序。

- multiset：与set类似，但允许键重复（支持多个相同元素）。

- map：存储键值对（key-value），键唯一，自动按 key 排序，可通过 key 快速查找 value。

- multimap：与map类似，但允许键重复（一个 key 可对应多个 value）。

### 3. 无序关联容器（Unordered Associative Containers）

**特点**：C++11 新增，元素不排序，底层基于哈希表实现，查找、插入、删除的平均效率为 O (1)（最坏 O (n)），适合需要快速查找但不关心顺序的场景。

包含的容器：

- unordered_set：存储唯一键，不排序，基于哈希表。

- unordered_multiset：与unordered_set类似，允许键重复。

- unordered_map：存储键值对，键唯一，不排序，基于哈希表。

- unordered_multimap：与unordered_map类似，允许键重复。

### 4. 容器适配器（Container Adapters）

**特点**：不直接存储元素，而是对现有容器（序列容器）进行封装，提供特定的接口（如栈、队列），隐藏底层容器的部分功能。

包含的容器：

- stack：栈，遵循 “后进先出（LIFO）”，默认基于deque实现，仅支持从顶部插入 / 删除 / 访问元素。

- queue：队列，遵循 “先进先出（FIFO）”，默认基于deque实现，仅支持从尾部插入、头部删除。

- priority_queue：优先队列，每次出队的是 “优先级最高” 的元素（默认最大元素），默认基于vector实现，底层通过堆结构维护优先级。



## 序列容器共同操作

C++ 序列容器（vector、deque、list、forward_list、array）尽管底层实现和特性不同，但提供了一系列**通用操作接口**，这些操作的语法和语义基本一致（个别容器因特性有例外）。以下是序列容器的主要共同操作：

### 1. 迭代器相关操作

所有序列容器都支持迭代器（iterator）来遍历元素，提供以下获取迭代器的函数：

- begin()：返回指向容器**第一个元素**的迭代器。

- end()：返回指向容器**最后一个元素后一位**的迭代器（“尾后” 迭代器，标记范围结束）。

- rbegin()：返回指向容器**最后一个元素**的反向迭代器（从后往前遍历）。

- rend()：返回指向容器**第一个元素前一位**的反向迭代器。

- 常量版本：cbegin()、cend()、crbegin()、crend()（返回const_iterator，确保不能通过迭代器修改元素）。

**例外**：无（所有序列容器均支持迭代器）。

### 2. 大小与容量操作

- size()：返回容器中**当前元素的数量**。

- empty()：判断容器是否为空（size() == 0时返回true）。

- max_size()：返回容器理论上能存储的**最大元素数量**（由系统和元素类型决定）。

**例外**：无（所有序列容器均支持）。

此外，部分容器（非固定大小）还支持：

- capacity()：返回容器当前**已分配的内存可容纳的元素数量**（仅vector、deque支持，list/forward_list/array无此接口）。

- reserve(n)：预分配至少能容纳n个元素的内存（仅vector、deque支持，避免频繁扩容）。

### 3. 元素访问操作

- front()：返回容器中**第一个元素的引用**（若容器为空，行为未定义）。

- back()：返回容器中**最后一个元素的引用**（若容器为空，行为未定义）。

**例外**：

- forward_list（单向链表）不支持back()（无法高效获取最后一个元素）。

- array、vector、deque还支持**随机访问**（operator[]和at(n)），但list和forward_list不支持（需通过迭代器遍历）。

### 4. 修改操作（部分容器支持，因是否可动态扩容而异）

#### （1）尾部操作

- push_back(val)：在容器**尾部插入元素**val。

- pop_back()：删除容器**尾部的元素**（不返回值，若容器为空，行为未定义）。

**例外**：

- array（固定大小）不支持（无法修改大小）。

- forward_list（单向链表）不支持（尾部操作效率极低，故未提供接口）。

#### （2）插入与删除

- insert(pos, val)：在迭代器pos指向的位置**插入元素**val，返回指向新插入元素的迭代器。

- erase(pos)：删除迭代器pos指向的元素，返回指向被删除元素后一位的迭代器。

- clear()：清空容器中所有元素（size()变为 0）。

**例外**：

- array（固定大小）不支持insert()、erase()、clear()（大小不可变）。

- forward_list的插入 / 删除接口不同（如insert_after()、erase_after()），因单向链表特性，无法在当前位置前插入 / 删除。

#### （3）其他修改

- assign(n, val)：替换容器中所有元素为n个val（覆盖原有内容）。

- swap(other)：交换当前容器与other容器的内容（效率通常很高，仅交换内部指针）。

**例外**：

- array的swap()会交换所有元素（因大小固定），而其他容器通常仅交换内部数据结构。

- 

C++ 关联容器（包括有序关联容器set/multiset/map/multimap和无序关联容器unordered_set/unordered_multiset/unordered_map/unordered_multimap）尽管底层实现不同（有序基于红黑树，无序基于哈希表），但作为 “通过键（key）管理元素” 的容器，它们提供了一系列**共有操作接口**，核心围绕 “键的查找、插入、删除” 等特性。

## 关联容器共同操作

### 1. 迭代器相关操作

所有关联容器均支持迭代器遍历，提供以下接口（与序列容器类似，但迭代器类型不同）：

- begin() / end()：返回指向**第一个元素**和**尾后位置**的迭代器。

- rbegin() / rend()：返回指向**最后一个元素**和**首前位置**的反向迭代器。

- 常量版本：cbegin() / cend() / crbegin() / crend()（返回const_iterator，禁止通过迭代器修改元素）。

**特性**：

- 有序关联容器的迭代器是**双向迭代器**（支持++/--），且遍历顺序与键的排序一致（默认升序）。

- 无序关联容器的迭代器是**前向迭代器**（仅支持++），遍历顺序不确定（与哈希值相关）。

### 2. 大小与状态操作

- size()：返回容器中当前元素的数量。

- empty()：判断容器是否为空（size() == 0时返回true）。

- max_size()：返回容器理论上可存储的最大元素数量（由系统和元素类型决定）。

**说明**：所有关联容器均支持，无例外。

### 3. 插入元素

关联容器通过insert()插入元素，具体行为因容器类型略有差异，但接口形式一致：

- 对于set/unordered_set：插入单个键（insert(key)）。

- 对于map/unordered_map：插入键值对（insert({key, value}) 或 insert(make_pair(key, value))）。

- 对于multiset/multimap及无序版本：允许插入重复键（set/map会忽略重复键的插入）。

**返回值**：

- 对于不允许重复键的容器（set/map/unordered_set/unordered_map）：返回pair<iterator, bool>，其中iterator指向插入位置（或已存在的元素），bool表示是否插入成功。

- 对于允许重复键的容器（multiset/multimap及无序版本）：仅返回指向新插入元素的迭代器。

### 4. 删除元素

关联容器通过erase()删除元素，支持多种删除方式（所有关联容器均支持）：

- erase(pos)：删除迭代器pos指向的元素，返回指向被删除元素后一位的迭代器。

- erase(key)：删除所有键为key的元素，返回**删除的元素数量**（set/map中为 0 或 1，multiset/multimap中可能≥1）。

- erase(first, last)：删除迭代器范围[first, last)内的所有元素，返回last迭代器。

### 5. 查找与计数

这是关联容器的核心操作，基于键实现高效查询：

- find(key)：查找键为key的元素，返回指向该元素的迭代器；若不存在，返回end()。

- count(key)：返回容器中键为key的元素数量（set/map中为 0 或 1，multiset/multimap中可能≥1）。

### 6. 交换与清空

- swap(other)：交换当前容器与other容器的内容（效率高，通常仅交换内部数据结构的指针）。

- clear()：清空容器中所有元素（size()变为 0，不释放内存）。

### 注意：有序与无序关联容器的操作差异

上述操作是所有关联容器的共有特性，但有序容器（set/multiset/map/multimap）还额外提供与 “排序” 相关的操作（如lower_bound/upper_bound），而无序容器（基于哈希表）不支持这些操作。因此，这些排序相关的操作不属于 “共有操作”。

## 无序关联容器共同操作

C++ 的无序关联容器（unordered_set、unordered_multiset、unordered_map、unordered_multimap）底层均基于**哈希表**实现，核心特性是 “通过键（key）快速访问元素” 且 “元素无序存储”。它们在操作接口上高度一致，以下是其共同操作：

### 1. 迭代器相关操作

所有无序关联容器均支持前向迭代器（仅支持++操作，不支持--），用于遍历元素：

- begin() / end()：返回指向**第一个元素**和**尾后位置**的迭代器（遍历顺序与哈希值相关，无固定顺序）。

- rbegin() / rend()：返回反向迭代器（从后往前遍历，仍基于前向迭代器模拟，顺序仍不确定）。

- 常量版本：cbegin() / cend() / crbegin() / crend()（返回const_iterator，禁止修改元素）。

### 2. 大小与状态操作

- size()：返回容器中当前元素的数量。

- empty()：判断容器是否为空（size() == 0时返回true）。

- max_size()：返回容器理论上可存储的最大元素数量（由系统、元素类型及哈希表实现决定）。

### 3. 插入元素

通过insert()插入元素，行为因 “是否允许重复键” 略有差异，但接口一致：

- 对于unordered_set/unordered_map（键唯一）：

插入单个元素（unordered_set插入key，unordered_map插入{key, value}），返回pair<iterator, bool>——iterator指向插入位置（或已存在的元素），bool表示是否插入成功（重复键会失败）。

- 对于unordered_multiset/unordered_multimap（允许重复键）：

插入单个元素，仅返回指向新插入元素的迭代器（无需判断是否重复）。

**特点**：插入位置由键的哈希值决定，与插入顺序无关。

### 4. 删除元素

支持三种删除方式（与关联容器一致）：

- erase(pos)：删除迭代器pos指向的元素，返回指向被删除元素后一位的迭代器。

- erase(key)：删除所有键为key的元素，返回**删除的元素数量**（unordered_set/unordered_map中为 0 或 1，unordered_multiset/unordered_multimap中可能≥1）。

- erase(first, last)：删除迭代器范围[first, last)内的元素，返回last迭代器。

### 5. 查找与计数（核心操作）

基于哈希表的高效查询，平均时间复杂度为 O (1)：

- find(key)：查找键为key的元素，返回指向该元素的迭代器；若不存在，返回end()。

- count(key)：返回容器中键为key的元素数量（unordered_set/unordered_map中为 0 或 1，unordered_multiset/unordered_multimap中可能≥1）。

### 6. 哈希与键比较相关操作（特有）

因底层依赖哈希表，无序容器提供哈希函数和键比较的接口：

- hash_function()：返回容器使用的哈希函数（类型为hasher），可用于计算键的哈希值。

- key_eq()：返回容器使用的键比较函数（类型为key_equal），用于判断两个键是否相等（默认是==）。

### 7. 桶操作（特有，与哈希表实现相关）

哈希表通过 “桶（bucket）” 组织元素（每个桶存储哈希值相同的元素），无序容器提供桶管理接口：

- bucket_count()：返回当前容器中的桶数量。

- max_bucket_count()：返回容器可容纳的最大桶数量。

- bucket_size(n)：返回第n个桶中存储的元素数量。

- bucket(key)：返回键key所在的桶的索引（范围为[0, bucket_count())）。

### 8. 负载因子与重哈希（特有）

负载因子（元素数量 / 桶数量）影响哈希表性能，无序容器提供相关操作：

- load_factor()：返回当前负载因子（size() / bucket_count()）。

- max_load_factor()：获取或设置最大负载因子（默认值因实现而异，超过此值会触发重哈希）。

- rehash(n)：强制将桶数量调整为至少n（可能触发重哈希，重新分配元素到新桶）。

- reserve(n)：预分配足够空间，确保容器可容纳n个元素而无需重哈希（内部会计算所需的桶数量）。

### 9. 交换与清空

- swap(other)：交换当前容器与other容器的内容（效率高，仅交换内部哈希表结构）。

- clear()：清空容器中所有元素（size()变为 0，但桶数量可能不变）。

## 容器适配器共同操作

C++ 的容器适配器（stack、queue、priority_queue）是对底层序列容器（如deque、vector）的封装，目的是提供特定的数据结构接口（栈、队列、优先队列），因此它们的操作接口被刻意简化，仅保留与自身特性匹配的核心功能。尽管三者的逻辑结构不同（LIFO、FIFO、优先级排序），但作为适配器，它们仍有一些**共有操作**：

### 1. 状态与大小操作

所有容器适配器都提供判断空状态和获取元素数量的接口：

- empty()：返回bool值，判断适配器是否为空（无元素时返回true）。

- size()：返回当前适配器中元素的数量（size_type类型）。

**示例**：

```
stack<int> s;
queue<int> q;
priority_queue<int> pq;

cout << s.empty() << endl;  // 输出1（true，初始为空）
cout << q.size() << endl;   // 输出0（初始无元素）
```

### 2. 插入元素

均通过push()接口在适配器的 “特定位置” 插入元素（位置由适配器类型决定）：

- stack（栈）：push(val)在**栈顶**插入元素。

- queue（队列）：push(val)在**队尾**插入元素。

- priority_queue（优先队列）：push(val)插入元素后，会自动调整结构，确保**优先级最高的元素在顶部**（默认最大元素）。

**示例**：

```
s.push(10);   // 栈顶添加10
q.push(20);   // 队尾添加20
pq.push(30);  // 插入30，优先队列顶部为30
```

### 3. 删除元素

均通过pop()接口删除适配器的 “特定位置” 元素（无返回值，需先判断非空）：

- stack：pop()删除**栈顶**元素。

- queue：pop()删除**队头**元素。

- priority_queue：pop()删除**顶部（优先级最高）** 元素。

**注意**：pop()仅删除元素，不返回被删除的值，若需获取值需先通过访问接口（如top()）读取。

**示例**：

```
if (!s.empty()) s.pop();   // 删除栈顶元素
if (!q.empty()) q.pop();   // 删除队头元素
if (!pq.empty()) pq.pop(); // 删除优先级最高的元素
```

### 4. 交换内容

均支持swap()操作，交换两个同类型适配器的内容（高效，通常仅交换底层容器的引用）：

- swap(other)：将当前适配器与other适配器的元素互换（两者必须是相同类型，如stack<int>之间）。

**示例**：

```
stack<int> s1, s2;
s1.push(1);
s2.push(2);
s1.swap(s2);  // s1现在包含2，s2包含1
```

### 5. 原位构造元素（C++11 起）

均支持emplace()接口，直接在适配器中构造元素（避免额外的拷贝 / 移动开销），功能类似push()，但参数为元素构造函数的参数：

- stack：emplace(args...)在栈顶直接构造元素。

- queue：emplace(args...)在队尾直接构造元素。

- priority_queue：emplace(args...)插入并构造元素，自动调整优先级。

**示例**：

```
// 假设元素类型为pair<int, string>
stack<pair<int, string>> s;
s.emplace(1, "a");  // 直接构造pair(1, "a")，等价于s.push({1, "a"})
```

### 关键限制（与其他容器的区别）

容器适配器的设计目标是 “限制访问方式”，因此它们**不支持迭代器**，也不提供随机访问、范围遍历等操作，仅允许通过特定接口（如top()、front()）访问 “特定位置” 的元素：

- stack和priority_queue仅提供top()访问顶部元素。

- queue提供front()（队头）和back()（队尾）访问。

